//////////////////// Section 1 ////////////////////////
a. React is all about single page applications. 
b. 

//////////////////// Section 2 ////////////////////////
a. Arrow functions take the invocation context outside of the equation when using "this"
b. Classes dont need the super() in the constructor like they used to 
    - class Human {
        gender = "male";

        printGender = () => {
            console.log(this.gender);
        }
    }
c. Spread and Rest
    - Spread: spreads array or object into other array or object
     i. const newArr = [...oldArr, 1, 2]
     ii. const newObj = {..oldObj, newThing: value, newerThing: value}
    - Rest: Spread a list of function arguements into and array
     i. function sortArgs(...args) {
         return args.sort();
     }
d. Destructuring
    - const [arrayThing, otherThing] = arrayOfThings;
    - const {objectThing, otherThing} = objectWithThings;

e. Array functions
    - filter, map, find, findIndex, reduce, concat, slice, splice, 
//////////////////// Section 3 ////////////////////////
a. react is written in a declarative way. We state the end goal for what stuff should
    look like, and react works it out. 
b. vanilla Js is written in an imperative way. We give step by step instructions for how 
    we want things to turn out. 
c. create a new project with npx create-react-app <appname>
d. components are returned JSX code
    - const comp = (props) => {
        return (
            <div>
                <p>I am Component!</p>
            <div>
        ) 
    }
e. props are passed down to JSX components from their parent. These look like attributes
    - <ParentComponent>
        <Component prop1={afunctionorvalue}></Component>
      </ParentComponent>

//////////////////// Section 4 ////////////////////////
a. Listening to events is built into React components. Each component can have "onEvent" attributes added to them
    - <Component onClick={someFunctionHandler} />
b. React relies heavily on "state". A component wont re-render unless some "state" is changed.
c. To use state, you need to import it from react, and destructure out two items, the states current value, and the function that updates that value
    - const [currentVal, setCurrentVal] = useState("bool, string, object, arr, etc.."), you can call that update the value for any reason, not just user events. Http requests, setTimeout, etc..
d. If a parent component is rea-evaluated, all the child components are called again as well. 
e. Two way binding is important.
    - adding a value attribute on an input for example, and setting it to a piece of state, allows us to set it back to whatever we want after that state updates.
f. Lifting information up through components works like event bubbling in JS. 
    - Pass an event handler from a parent component to a child component
    - call that handler in the child component and pass in the data you want to pass up.
    - Repeat this all the way up the chain
    - this is called "lifting the state"

//////////////////// Section 5 ////////////////////////
a. You can conditionally render content in a few ways
    - Using {} to add expressions directly in your JSX code
        i. 
        import item from './item.js'

        const thing = () = {
        let items = [item1, item2]
        const addItemHandler = (item) => {
            return items.push(item)
        }

        return(
            <Component>
                {items.map((item => return <Item><p>`${item.name}`</p></Item))}
            </Component>
        )
            
        }
    - Defining content in the JS above the JSX, and then putting in the JSX in curly braces
        ii. 
        import item from './item.js'

        const thing = () = {
        let items = [item1, item2]
        const addItemHandler = (item) => {
            return items.push(item)
        }

        const itemList = (items) => {
            items.map((item => return <Item><p>`${item.name}`</p></Item))
        }

        return(
            <Component>
                {itemList}
            </Component>
        )
            
        }
    - Using Ternary Operators to apply text, components, or styles
      iii.
      {if(!isValid) && <Component/} 
      {if(isValue && <OtherComponent/>)}
      {items.length === 0 ? <p>No Items</p> : <Component>{itemList}<Component/>}
    - Checking for content in your Js above your component, and returning early with a seperate component if a condition is not met.

//////////////////// Section 6 ////////////////////////
a. You can add dynamic styles on components with inline styles or Classes
    - <Component style={{
        backgroundColor: !isValid ? "red : "white",
        borderColor: !isValid ? "red" : "blue"
    }}/>
    - <Component className={`form-control ${isValid ? 'invalid' : ""}`} />
b. You can also use the "styled-components" npm package. 
    - import styled from "styled-components"
    - const Button = styled.whateverelement`stylesgohere`

//////////////////// Section 1 ////////////////////////




//////////////////// Section 1 ////////////////////////



//////////////////// Section 1 ////////////////////////


//////////////////// Section 1 ////////////////////////

