//////////////////// Section 1 Getting Started////////////////////////
a. React is all about single page applications. 
b. 

//////////////////// Section 2 JS refresher ////////////////////////
a. Arrow functions take the invocation context outside of the equation when using "this"
b. Classes dont need the super() in the constructor like they used to 
    - class Human {
        gender = "male";

        printGender = () => {
            console.log(this.gender);
        }
    }
c. Spread and Rest
    - Spread: spreads array or object into other array or object
     i. const newArr = [...oldArr, 1, 2]
     ii. const newObj = {..oldObj, newThing: value, newerThing: value}
    - Rest: Spread a list of function arguements into and array
     i. function sortArgs(...args) {
         return args.sort();
     }
d. Destructuring
    - const [arrayThing, otherThing] = arrayOfThings;
    - const {objectThing, otherThing} = objectWithThings;

e. Array functions
    - filter, map, find, findIndex, reduce, concat, slice, splice, 
//////////////////// Section 3 React Basics ////////////////////////
a. react is written in a declarative way. We state the end goal for what stuff should
    look like, and react works it out. 
b. vanilla Js is written in an imperative way. We give step by step instructions for how 
    we want things to turn out. 
c. create a new project with npx create-react-app <appname>
d. components are returned JSX code
    - const comp = (props) => {
        return (
            <div>
                <p>I am Component!</p>
            <div>
        ) 
    }
e. props are passed down to JSX components from their parent. These look like attributes
    - <ParentComponent>
        <Component prop1={afunctionorvalue}></Component>
      </ParentComponent>

//////////////////// Section 4 React State and Events ////////////////////////
a. Listening to events is built into React components. Each component can have "onEvent" attributes added to them
    - <Component onClick={someFunctionHandler} />
b. React relies heavily on "state". A component wont re-render unless some "state" is changed.
c. To use state, you need to import it from react, and destructure out two items, the states current value, and the function that updates that value
    - const [currentVal, setCurrentVal] = useState("bool, string, object, arr, etc.."), you can call that update the value for any reason, not just user events. Http requests, setTimeout, etc..
d. If a parent component is rea-evaluated, all the child components are called again as well. 
e. Two way binding is important.
    - adding a value attribute on an input for example, and setting it to a piece of state, allows us to set it back to whatever we want after that state updates.
f. Lifting information up through components works like event bubbling in JS. 
    - Pass an event handler from a parent component to a child component
    - call that handler in the child component and pass in the data you want to pass up.
    - Repeat this all the way up the chain
    - this is called "lifting the state"

//////////////////// Section 5 Rendering Lists and Conditional Content ////////////////////////
a. You can conditionally render content in a few ways
    - Using {} to add expressions directly in your JSX code
        i. 
        import item from './item.js'

        const thing = () = {
        let items = [item1, item2]
        const addItemHandler = (item) => {
            return items.push(item)
        }

        return(
            <Component>
                {items.map((item => return <Item><p>`${item.name}`</p></Item))}
            </Component>
        )
            
        }
    - Defining content in the JS above the JSX, and then putting in the JSX in curly braces
        ii. 
        import item from './item.js'

        const thing = () = {
        let items = [item1, item2]
        const addItemHandler = (item) => {
            return items.push(item)
        }

        const itemList = (items) => {
            items.map((item => return <Item><p>`${item.name}`</p></Item))
        }

        return(
            <Component>
                {itemList}
            </Component>
        )
            
        }
    - Using Ternary Operators to apply text, components, or styles
      iii.
      {if(!isValid) && <Component/} 
      {if(isValue && <OtherComponent/>)}
      {items.length === 0 ? <p>No Items</p> : <Component>{itemList}<Component/>}
    - Checking for content in your Js above your component, and returning early with a seperate component if a condition is not met.
    - whenever you are making a list, make sure your objects have an id. That Id needs to be placed as a "key"
        attribute on your JSX element when you render the content so react can intuitively re-render that content
            if it is updated
            
//////////////////// Section 6 Styles ////////////////////////
a. You can add dynamic styles on components with inline styles or Classes
    - <Component style={{
        backgroundColor: !isValid ? "red : "white",
        borderColor: !isValid ? "red" : "blue"
    }}/>
    - <Component className={`form-control ${isValid ? 'invalid' : ""}`} />
b. You can also use the "styled-components" npm package. 
    - import styled from "styled-components"
    - const Button = styled.whateverelement`stylesgohere`
c. In the styles you pass into the backticks, you can use a prop on the component being styled, 
    and then use that prop to set styles dynamically based on its value.
d. CSS Modules
    - import styles from "./Button.module.css";
    - Name your css files "Component.module.css"
    - you now have access to your classes as properties on "styles"
        - <Component className={styles.className}/>
        - <Component className={styles[class-name]}/>
    - You can add dynamic styles like this:
        - <Component className={`${styles["form-control"]} ${!isValid && styles.invalid}`}/>
    - Media Queries work as normal (Try to make queries for bigger screens not smaller ones)
e. Your custom elements dont know what className or other built in attributes are. 
    - if you want to pass a class from a custom component down to is children, you do so
        by accessing that className prop from the parent on the children.

//////////////////// Section 8 addusers project////////////////////////
1. When you create a custom component like a button, rather than adding the onClick on the 
    JSX <button></button> within the component, you can add it on the parent custom made <Button></Button> as props.
    This allows you to have custom buttons, but pass in different handlers, types, etc
    based on where you are using them. You simplly set the <button> attributes to be prop values
    in your custom <Button></Button> component.



//////////////////// Section 9 Fragments Portals and Refs ////////////////////////
1. JSX code can only return one "root" html element. Two elements cannot be returned side
    by side. 
    - This makes sense, because in JS you cant return more than one thing either.
    - To work around this, you can wrap everything in one element.
    - You can also make what you return an array of elements. However if you do this, react wants a key on 
        each element, just like it does when you dynamically render lists of data as elements.  
2. The ideal solution to the above is to use a wrapper component.
    - The wrapper component can just return props.children, or, any elements nested inside
        the wrapper.
    - SUPRISE! This is actually already built for you as <React.Fragment></React.Fragment>
        - some projects can support <></> as <React.Fragment></React.Fragment>
    - We can now avoid using a bunch of uneccessary div.
3. Portals. Because modals are overlays for the entire page, you dont want them nested
    inside a bunch of elements.
    - We can use portals to render HTML outside of the component we are rendering.
4. To use a portal
    - create an element in index.html with the id you want to render the component in
    - call ReactDom.createPortal(<Component/>, document.getElementId("someid"));
5. "refs"
    - You can set a connection to an HTML element and other js code
    - const thing = useRef(), and then setting ref={thing} on an element connects them
        - the value of "thing" is the actual element itslef at first
        - you can access an elements value with: element.current.value
        - this can eliminate the need to use state to keep track of values in some cases.
6. When you access a compenets value but you arent using react to determine that value 
    like with state or something similar, these are called uncontrolled components. 
    - most often this happens with input components. 


//////////////////// Section 10 useEffect, useReducer, and the context API ////////////////////////
1. useEffect is for "side-effects", or anything that is not rendering a ui or reacting to user input.
2. useEffect takes in two arguments:
    a. Callback function
    b. array of dependencies, the callback only runs if the dependencies change
       - without the second argument, it runs everytime the state updates
       - with an empty array as the second argument, the effect only runs once on mount
3. Generally, the depencies are what you are using in your side effect function
4. Remember, useEffect can be used for anything that is a sideeffect of something else happening within
    a component.
5. Sometimes you need to "cleanup" after re-render. For example, if you add an eventlistener
    in useEffect, you dont want to add an eventListener EVERY time a depency changes.
6. You can "return" a function in useEffect to clean up the results from the last time it reason
    - if you added an even listener, and the same thing happens again, your returned
        function that gets rid of the eventlister will run first. This avoids 50 event
        listeners being added to the same thing.

1. useReducer is a more complex version of useState()
2. It is good to use when you have state updates that belong together, or you have
    state updates that depend on other state updates.
3. const [state, dispatchFn] = useReducer(reducerFn, initialState, initFn);
    - reducerFn(prevState, action) <- action is the entire object you pass into your dispatch function
    - initialState - the initial state that was set
    - initFn - function to set the initial state programmatically (Like an http req)
4. All use reducer really does is allow you to turn state into an object rather
    than a value. 
    - you then pass another object as an action
    - you then return your new state. You can access the old state and the new action object
        in the process. 
    If you use useEffect with useReducer, make sure you depencies dont lead
    to uneccessary effect execution. 

1. Create a context object file within your source folder
2. React.createContext({yourcontextkeyvalues})
3. You then have to import and wrap any component that will need access to this context
4. <AuthContext.Provider> wrapping gives all component children the context
5. For components who want to use the provider, you can wrap them in a consumer
5. <AuthContext.Consumer> has a child that is a function. 
 - The function takes in the context as an argument, and should return your JSX that
    needs to use the context.
 - You can now access the context properties. ctx.property

1. Most of the time we will use the useContext hook. 
2. const ctx = useContext(AuthContext) <--- Still need to import your context
3. in your context provider, you can also pass down functions. 
4. Remember, you only do this when you are forwarding value/functions through components. 
    - If you are going to to use the value/function in a direct child, go ahead and use props Still

1. When you pass functions, you dont have to declare them on the context instantiation object
    itself. You can throw the key in, and put a dummy function in its place. You can 
    then make the function in a component, and pass it into the Context.Provider as a value.

1. React Context is not optimized for high frequency changes. 
2. The Rules of React Hooks
    - You can only call hooks in react functions. Compenent functions, and custom hooks.
    - You can only call hooks at the top level of your react function
        - Dont call them in nested functions
        - dont call them in block statements
3. useEffect(), everything used in useEffect needs to be added as a dependency.

1. useImperativeHandle
 -  Custom components cannot use refs.
 -  useImperativeHandle takes in , and a function that returns an object. This
    object has key value pairs that can make functions accessible to custom compenents.
 - You will have to pass a ref on your custom compenent, and pass that to the
    useImperativeHandle(ref, function that returns object)
 - If you want to do this on a custom component, you need to wrap it in
   React.forwardRef
 - now you have a ref on your reusuable component and can access the functions
    you returned in useImperativeHandle.

//////////////////// Section 12 How React Works ////////////////////////
 - Just because a comonent re-renders, does mean the dom re-renders. React on re-renders a targeted dom element. 



Project:
1. I want a side-drawer nested nav

- useState()
- useRef()
- React.Fragment
- ReactDom.createPortal()
- useEffect()
- debounce something
- useReducer();
    - destructered variables from the state
- useContext(); - Custom context component
- useImperativeHandle();
- useForwardRef();

1. Make a compenent tree and get an idea of what components need to be resuable.
2. Decide where you will need to use context to avoid passing state through muliple compenents

1. Check to see if a sentance contains every letter in the alphabet.
    - accepts a str - true if every letter A-z false if not.




Jobs
- Create a Job with a description and date. 
- Mark job as new, in progress on complete.
- send an invoice to the client for that Job.
- client should be able to make a payment.

Trans
- Use portal for trans detail
- use context for display state
- use reduce for search form
